/*
 * Copyright 2014, Stratio.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.stratio.deep.utils;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.mapreduce.*;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;

/**
 * Created by rcrespo on 22/08/14.
 */
public class DeepSparkHadoopMapReduceUtil {


    public static JobContext newJobContext(Configuration conf, JobID jobId) {
        try {
            Class clazz = firstAvailableClass(
                    "org.apache.hadoop.mapreduce.task.JobContextImpl",  // hadoop2, hadoop2-yarn
                    "org.apache.hadoop.mapreduce.JobContext");           // hadoop1


            Constructor constructor = clazz.getDeclaredConstructor(Configuration.class, JobID.class);

            return (JobContext) constructor.newInstance(conf, jobId);
            //TODO autogenerated
        } catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) {
            e.printStackTrace();
        }
        return null;
    }

    public static TaskAttemptContext newTaskAttemptContext(Configuration conf, TaskAttemptID attemptId) {
        try {
            Class clazz = firstAvailableClass(
                    "org.apache.hadoop.mapreduce.task.TaskAttemptContextImpl",  // hadoop2, hadoop2-yarn
                    "org.apache.hadoop.mapreduce.TaskAttemptContext");           // hadoop1
            Constructor constructor = clazz.getDeclaredConstructor(Configuration.class, TaskAttemptID.class);
            return (TaskAttemptContext) constructor.newInstance(conf, attemptId);

        } catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) {
            e.printStackTrace();
        }
        return null;
    }

    public static TaskAttemptID newTaskAttemptID(String jtIdentifier, int jobId, boolean isMap, int taskId, int attemptId) {
        Class clazz = null;
        try {
            clazz = Class.forName("org.apache.hadoop.mapreduce.TaskAttemptID");
            Constructor constructor = clazz.getDeclaredConstructor(String.class, int.class, boolean.class, int.class, int.class);
            return (TaskAttemptID) constructor.newInstance(jtIdentifier, jobId, isMap, taskId, attemptId);
        } catch (ClassNotFoundException | NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) {

            try {

                // If that failed, look for the new constructor that takes a TaskType (not available in 1.x)
                Class taskTypeClass = Class.forName("org.apache.hadoop.mapreduce.TaskType");

                Method taskType = taskTypeClass.getMethod("valueOf", String.class);


                TaskType type = null;
                if (isMap) {
                    type = TaskType.MAP;
//                        taskType.invoke(taskTypeClass, "MAP");
                } else {
                    type = TaskType.REDUCE;
//                        taskType.invoke(taskTypeClass, "REDUCE");
                }

                Constructor constructor = clazz.getDeclaredConstructor(String.class, int.class, taskTypeClass,
                        int.class, int.class);
                return (TaskAttemptID) constructor.newInstance(jtIdentifier, jobId, type, taskId,
                        attemptId);
            } catch (ClassNotFoundException | NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e1) {
                e.printStackTrace();
                e1.printStackTrace();
            }
        }
        return null;
    }

    private static Class firstAvailableClass(String first, String second) {

        try {
            return Class.forName(first);
        } catch (ClassNotFoundException e) {
            try {
                return Class.forName(second);
            } catch (ClassNotFoundException e1) {
                return null;
            }
        }
    }

}
